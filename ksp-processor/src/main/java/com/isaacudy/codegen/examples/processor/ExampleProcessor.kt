package com.isaacudy.codegen.examples.processor

import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.squareup.kotlinpoet.ClassName

/**
 * This is an example of a KSP processor that will create a new file called "PreviewCatalogueScreen.kt",
 * which contains a composable function that displays all the @Preview functions in the project.
 */
class ExampleProcessor(
    private val environment: SymbolProcessorEnvironment,
) : SymbolProcessor {

    // KSP processors can be called multiple times, because code that is generated by one processor
    // can trigger another round of processing if it contains annotations that are processed by another
    // processor. Because this is a simple example, we're not going to bother processing more than once,
    // so we'll set "processed" to true after the first processing round, and then do an early return
    // if the processor is called again.
    private var processed = false

    private val previewAnnotationName = ClassName("androidx.compose.ui.tooling.preview", "Preview")

    /**
     * This function is called by the KSP framework to process the symbols in the project.
     * In this case, we're looking for symbols with the @Preview annotation, and generating a new file
     * that displays all the @Preview functions in a single screen.
     */
    override fun process(resolver: Resolver): List<KSAnnotated> {
        // See if we've already performed processing, and if so, return an empty list
        if (processed) return emptyList()
        processed = true

        // Find all symbols with the @Preview annotation, and then filter these so we're only
        // looking at function declarations.
        val previews = resolver
            .getSymbolsWithAnnotation(previewAnnotationName.canonicalName)
            .filterIsInstance<KSFunctionDeclaration>()

        // Based on the preview functions, generate the content for the PreviewCatalogueScreen.kt file
        val content = generatePreviewCatalogueContent(
            previews = previews.toList()
        )

        // Create a new file, and then write the generated content to the file
        environment.codeGenerator.createNewFileByPath(
            dependencies = Dependencies(
                aggregating = true,
                sources = previews.map { it.containingFile!! }.toList().toTypedArray()
            ),
            path = "com/isaacudy/codegen/examples/generated/PreviewCatalogueScreen.kt"
        ).use { writer ->
            writer.bufferedWriter()
                .use { it.write(content) }
        }

        // the process function should return a list of symbols that were not able to be processed
        // in this round of processing. In this case, we're not doing any further processing, so we
        // just return an empty list.
        return emptyList()
    }
}

/**
 * This function generates the content of the PreviewCatalogueScreen.kt file, based on
 * the list of @Preview functions provided through the [previews] parameter.
 *
 * In a more complex project, you'd likely use something like KotlinPoet to generate this content,
 * but in a simple example, it's easier to just write the content as a string.
 */
private fun generatePreviewCatalogueContent(previews: List<KSFunctionDeclaration>): String {
    return """
package com.isaacudy.codegen.examples.generated

import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.ExperimentalComposeUiApi
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInteropFilter
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp

${
        // We need to provide an import statement for each preview function,
        // so that we can reference them in the generated content.
        previews.joinToString("\n") {
            "import ${it.containingFile!!.packageName.asString()}.${it.simpleName.asString()}"
        }
    }

@Composable
@OptIn(ExperimentalComposeUiApi::class)
fun PreviewCatalogueScreen() {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
            .verticalScroll(rememberScrollState())
            .pointerInteropFilter { true },
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            text = "Preview Catalogue", 
            style = MaterialTheme.typography.headlineLarge,
            fontWeight = FontWeight.Bold,
        )
        Spacer(modifier = Modifier.height(8.dp))
        ${
        previews.joinToString("\n") {
            createPreviewSection(it)
                // add two levels of indentation to the preview section content,
                // to make it look nice in the generated file
                .prependIndent()
                .prependIndent()
        }
    }
    }
}
""".trimIndent()
}

/**
 * This function generates the content for a single preview section, based on the provided
 * [previewFunction].
 */
private fun createPreviewSection(
    previewFunction: KSFunctionDeclaration
): String {
    val previewFunctionName = previewFunction.simpleName.asString()
    val previewTitleName = previewTitleText(previewFunctionName)
    return """
        Text(text = "$previewTitleName", style = MaterialTheme.typography.bodySmall)
        Box(
            modifier = Modifier
            .padding(bottom = 16.dp)
            .border(1.dp, MaterialTheme.colorScheme.onSurface.copy(alpha = 0.06f), MaterialTheme.shapes.medium)
            .padding(8.dp)
            .fillMaxWidth()
        ) {
            $previewFunctionName()
        }
    """.trimIndent()
}

/**
 * This is a helper function for generating a human-readable title from a preview function's name.
 * The function will split the function's name on the substring "Preview", insert spaces
 * before capital letters, and add brackets around the substring that comes after "Preview".
 *
 * Examples:
 * CoolFunctionPreview -> Cool Function
 * CoolFunctionPreviewExtra -> Cool Function (Extra)
 * FunctionWithALongNamePreviewSpecialInformation -> Function With A Long Name (Special Information)
 */
private fun previewTitleText(previewName: String): String {
    val split = previewName.split("Preview").filter { it.isNotBlank() }
    val name = split.first().fold("") { acc, c ->
        if (c.isUpperCase()) {
            "$acc $c"
        } else {
            "$acc$c"
        }
    }
    if (split.size == 1) return name
    val extraInfo = split.getOrNull(1).orEmpty().fold("") { acc, c ->
        if (c.isUpperCase() && acc.isNotEmpty()) {
            "$acc $c"
        } else {
            "$acc$c"
        }
    }
    return "$name ($extraInfo)"
}